/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["SimplePS"] = factory();
	else
		root["SimplePS"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BuiltIn: () => (/* reexport safe */ _simple_ps__WEBPACK_IMPORTED_MODULE_0__.BuiltIn),\n/* harmony export */   Engine: () => (/* reexport safe */ _simple_ps__WEBPACK_IMPORTED_MODULE_0__.Engine)\n/* harmony export */ });\n/* harmony import */ var _simple_ps__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./simple-ps */ \"./src/simple-ps.js\");\n\n\n\n\n\n//# sourceURL=webpack://SimplePS/./src/index.js?");

/***/ }),

/***/ "./src/parser.js":
/*!***********************!*\
  !*** ./src/parser.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parse: () => (/* binding */ parse)\n/* harmony export */ });\n/* harmony import */ var _simple_ps__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./simple-ps */ \"./src/simple-ps.js\");\n/*\n * 文字列を受け取りRuleの配列を返すパーサであるrules()関数を提供。\n * もしエラーがあったらエラーメッセージの文字列を返す。\n */\n\n\n// 識別子の最初の文字にマッチする正規表現\nconst rx_id1st = new RegExp('[a-zA-Z_\\u00c0-\\u1fff\\u3040-\\u318f\\u3400-\\u3d2d\\u4e00-\\u9fff\\uf900-\\ufaff]');\n// 識別子の2文字目以降の文字にマッチする正規表現\nconst rx_id2nd = new RegExp('[a-zA-Z_\\u00c0-\\u1fff\\u3040-\\u318f\\u3400-\\u3d2d\\u4e00-\\u9fff\\uf900-\\ufaff0-9]');\n// 数字と判定される文字にマッチする正規表現\nconst rx_num = new RegExp('[0-9]');\n\n// 再帰下降構文解析で解析する。方針としてグローバル変数の\n// inputStrに解析文字列を入れといて、基本1文字ずつ解析。\n// その文字の位置を常にグローバル変数のidx変数に保存。\n// 解析関数はinputStr.charAt(idx)から\n// 解析を始める。その時に必要であれば解析が失敗することを\n// 考慮してidxをidxBackupに保存しておく。もし、解析が成功\n// したらidxは次に解析される文字の所まで進めておく義務がある。\n// なおかつreturnで解析結果を返す。もし、解析が失敗したら\n// エラーメッセージをグローバル変数のerrorMessageに書き込み、\n// バックアップしていたidxBackupをidxに代入して戻しておく。\n// なおかつreturnでnullを返すことにする。\n\nlet inputStr; // 解析する文字列(普通は\\nが入った複数行の文字列)\nlet idx; // 現在解析しているinputStr中の一文字の場所\nlet errorMessage; // エラーメッセージを記録しておく場所\n\n// 現在解析している場所の行番号と列番号を文字列で返す関数。\n// エラーメッセージ作る時に使おう。\nfunction lineColumnNo() {\n  let line = 1;\n  let column = 1;\n  for (let i=0;i<idx;i++) {\n    if (inputStr.charAt(i)==='\\n') {\n      line++;\n      column = 1;\n    } else {\n      column++;\n    }\n  }\n  return \"\"+line+\":\"+column;\n}\n\n// 指定した1文字を検出する解析関数\nfunction char(c) {\n  if (inputStr.charAt(idx)===c) {\n    idx++;\n    return c;\n  }\n  errorMessage = `Error(${lineColumnNo()}) ここには文字「${c}」がこなければなりません。`;\n  return null;\n}\n\n// コメントは「/*」で始まり「*/」で終るコメントのみ許可\nfunction comment() {\n  const idxBackup = idx;\n  if (char('/')) {\n    if (char('*')) {\n      while (true) {\n\tconst idxBackup2 = idx;\n\tif (char('*')) {\n\t  if (char('/')) {\n\t    return \"comment\";\n\t  }\n\t}\n\tidx = idxBackup2;\n\tif (inputStr.charAt(idx)==='') {\n\t  idx = idxBackup;\n\t  errorMessage = `Error(${lineColumnNo()}) ここにはコメントがこなければなりません。`;\n\t  return null;\n\t}\n\tidx++;\n      }\n    }\n  }\n  idx = idxBackup;\n  errorMessage = `Error(${lineColumnNo()}) ここにはコメントがこなければなりません。`;\n  return null;\n}\n\n// 半角空白、タブ、改行の時成功。それ以外は失敗。\nfunction whiteChar() {\n  if (char(' ')) return ' ';\n  if (char('\\t')) return '\\t';\n  if (char('\\n')) return '\\n';\n  errorMessage = `Error(${lineColumnNo()})`;\n  return null;\n}\n\n// whiteSpaceまたは空文字列を検出。なので絶対成功する。\n// つまりスペースが入ってても良いし入ってなくても良い\n// ような場所で使う。あとコメント文もwhiteSpace扱いに\n// することにした。\nfunction whiteSpace() {\n  while (true) {\n    const cmt = comment();\n    if (cmt)\n      continue;\n    const w = whiteChar();\n    if (w == null)\n      return \"whiteSpace\";\n  }\n}\n\n// 関数名、変数名などの名前に相当する識別子を検出する\nfunction id() {\n  const idxBackup = idx;\n  let name = '';\n  let c = inputStr.charAt(idx);\n  if (!c.match(rx_id1st)) {\n    errorMessage = `Error(${lineColumnNo()}) ここには識別子がくるべきです。`;\n    return null;\n  }\n  name += c;\n  while (true) {\n    idx++;\n    c = inputStr.charAt(idx);\n    if (!c.match(rx_id2nd))\n      return name;\n    name += c;\n  }\n}\n\n// whiteSpaceを読み飛ばして入力文字列の終りを検出する\nfunction eof() {\n  const idxBackup = idx;\n  const w = whiteSpace(); // 絶対成功する\n  const c = inputStr.charAt(idx); // idxが範囲外の時は空文字列\n  if (c === '')\n    return \"EOF\";\n  // ここまで来たら何か文字が残ってるのでエラー\n  idx = idxBackup;\n  errorMessage = `Error(${lineColumnNo()}): EOF(入力の最後でなければなりません。`;\n  return null;\n}\n\n// 文字列を解析する。\n// まだ文字列中の引用符のエスケープとかには対応してない。\nfunction string() {\n  const idxBackup = idx;\n  let a = char('\"');\n  if (a==null)\n    a = char(\"'\");\n  if (a==null) {idx=idxBackup;return null;}\n  let s = '';\n  while (true) {\n    const c = inputStr.charAt(idx);\n    if (c === '') {\n      idx = idxBackup;\n      errorMessage = `Error(${lineColumnNo()}) 文字列解析中に入力が終了しました。`;\n      return null;\n    }\n    if (c === a) {\n      idx++;\n      break;\n    }\n    s += c;\n    idx++;\n  }\n  return s;\n}\n\n// 数字を解析する。\nfunction number() {\n  const idxBackup = idx;\n  let c = inputStr.charAt(idx);\n  if (c !== '.' && !c.match(rx_num)) {\n    errorMessage = `Error(${lineColumnNo()}) ここには数字がこなければなりません。`;\n    return null;\n  }\n  let num = '';\n  if (c === '.') { // '.'で始まる特殊な場合\n    idx++; c = inputStr.charAt(idx);\n    if (!c.match(rx_num)) {\n      idx = idxBackup;\n      return null;\n    }\n    idx = idxBackup;\n    c = inputStr.charAt(idx);\n  } else { // ここにくるのは整数部分\n    num += c;\n    idx++; c = inputStr.charAt(idx);\n    while (c.match(rx_num)) {\n      num += c;\n      idx++; c = inputStr.charAt(idx);\n    }\n  }\n  if (c === '.') { // 小数部分\n    num += c;\n    idx++; c = inputStr.charAt(idx);\n    while (c.match(rx_num)) {\n      num += c;\n      idx++; c = inputStr.charAt(idx);\n    }\n  }\n  if (c === 'e' || c === 'E') {\n    num += c;\n    idx++; c = inputStr.charAt(idx);\n    if (c === '+' || c === '-') {\n      num += c;\n      idx++; c = inputStr.charAt(idx);\n    }\n    while (c.match(rx_num)) {\n      num += c;\n      idx++; c = inputStr.charAt(idx);\n    }\n  }\n  return Number(num);\n}\n\n// 項(条件やビルトインなど)を解析。項は関数の形をしている。\nfunction term() {\n  const idxBackup = idx;\n  const name = id();\n  if (name == null) return null;\n    whiteSpace();\n  if (char('(') == null) {idx=idxBackup;return null};\n  const args = []; // 引数の配列\n  while (true) {\n    whiteSpace();\n    if (inputStr.charAt(idx) === ',')\n      idx++;\n    whiteSpace();\n    const v = id(); if (v) {args.push(new _simple_ps__WEBPACK_IMPORTED_MODULE_0__.Var(v));continue;} // 変数\n    const n = number(); if (n) {args.push(n);continue;} // 数字\n    const s = string(); if (s) {args.push(s);continue;} // 文字列\n    break;\n  }\n  whiteSpace();\n  if (char(')') == null) {idx=idxBackup;return null};\n  whiteSpace();\n  if (inputStr.charAt(idx) === ',')\n    idx++;\n  return new _simple_ps__WEBPACK_IMPORTED_MODULE_0__.Term(name,args);\n}\n\n// ルール1本分。Ruleのインスタンスを返す。エラーならエラーメッセージを返す。\nfunction rule() {\n  const idxBackup = idx;\n  whiteSpace();\n  const priority = number();\n  if (priority == null) { idx=idxBackup; return null; }\n  whiteSpace();\n  if (char(':') == null) { idx=idxBackup; return null; }\n  const lhs = [];\n  while (true) {\n    whiteSpace();\n    const cond = term(); // 1つの条件に該当\n    if (cond == null) break;\n    lhs.push(cond);\n  }\n  if (lhs.length === 0) {\n    errorMessage = `Error(${lineColumnNo()}) 条件部(LHS)がありません。`;\n    idx=idxBackup;\n    return null;\n  }\n  whiteSpace();\n  //if (char('-') == null) { idx=idxBackup; return null; } // やっぱり入れない\n  if (char('>') == null) { idx=idxBackup; return null; }\n  const rhs = [];\n  while (true) {\n    whiteSpace();\n    const com = term(); // 1つの実行命令に該当\n    if (com == null) break;\n    rhs.push(com);\n  }\n  if (rhs.length === 0) {\n    errorMessage = `Error(${lineColumnNo()}) 実行部(RHS)がありません。`;\n    idx=idxBackup;\n    return null;\n  }\n  whiteSpace();\n  if (char(';') == null) { idx=idxBackup; return null; }\n  return new _simple_ps__WEBPACK_IMPORTED_MODULE_0__.Rule(priority,lhs,rhs);\n}\n\n// ルールの集合。ここが文法解析の出発点。\nfunction rules() {\n  const idxBackup = idx;\n  const rs = [];\n  while (true) {\n    const e = eof();\n    if (e)\n      break; // 正常終了\n    whiteSpace();\n    const r = rule();\n    if (r) {\n      rs.push(r);\n      continue;\n    }\n    // ここまで来たら何かエラー\n    idx = idxBackup;\n    // errorMessageはrule()の時のエラーを残す\n    return null;\n  }\n  return rs;\n}\n\n// 文法解析を実行する関数。\n// 解析するための文字列を引数で渡す。色々初期化してからスタート。\n// 解析が成功したらRuleの配列を返す。そして、解析失敗の\n// 時はエラーメッセージの文字列を返す。\n// 入力が空っぽの時も成功と見なして空の配列を返す。\nfunction parse(input) {\n  inputStr = input;\n  idx = 0;\n  errorMessage = \"\";\n\n  const rs = rules();\n  if (rs === null)\n    return errorMessage;\n  return rs;\n}\n\n\n\n\n//# sourceURL=webpack://SimplePS/./src/parser.js?");

/***/ }),

/***/ "./src/simple-ps.js":
/*!**************************!*\
  !*** ./src/simple-ps.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BuiltIn: () => (/* binding */ BuiltIn),\n/* harmony export */   Engine: () => (/* binding */ Engine),\n/* harmony export */   Rule: () => (/* binding */ Rule),\n/* harmony export */   Term: () => (/* binding */ Term),\n/* harmony export */   Var: () => (/* binding */ Var)\n/* harmony export */ });\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parser */ \"./src/parser.js\");\n\n\n// 推論システム\n// 推論は常に完全に停止して終了するタイプではなく\n// ワーキングメモリの状況に変化があれば自動で\n// 推論を再開するようにする。\n// ただ、無駄にCPUを消費することが無いように、\n// ワーキングメモリに変化が無い時は自動で\n// スリープ状態にする。\n// 上記を実現する方針は、Java版SimplePSを参考に\n// するべし。\n\n//変数\nclass Var {\n  name;\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nclass Term {\n  name; // 関数名に相当する部分\n  args; // 引数部分\n  constructor(name,args) {\n    this.name = name;\n    this.args = args;\n  }\n  toString() {\n    let str = \"\";\n    str += this.name + \"(\"\n    this.args.forEach((arg)=>{\n      if (typeof arg === \"number\")\n        str += arg + \" \";\n      else if (typeof arg === \"string\")\n        str += '\"' + arg + '\" ';\n      else if (arg.constructor.name === \"Var\")\n        str += arg.name + \" \";\n      else\n        str += \"??? \";\n    });\n    str += \")\"\n    return str;\n  }\n  // このTermの引数の中に情報名(変数)が\n  // あったら、その情報名でWMを検索しupdateTimeを\n  // 抽出し、その一番新しい値(最大値)を返す。\n  newestTime(engine) {\n    let newestTime = 0;\n    this.args.forEach((arg)=>{\n      if (arg.constructor === \"Var\") {\n        const updateTime = engine.getInfoUpdateTime(arg.name);\n        if (newestTime < updateTime)\n          newestTime = updateTime;\n      }\n    });\n    return newestTime;\n  }\n}\n\nclass Rule {\n  engine; // このルールを読み込んだEngine。後でengine自身ががセット\n  priority; // 優先度\n  lhs; // 条件部(Left Hand Side)(Termの配列)\n  rhs; // 実行部(Right Hand Side)(Termの配列)\n  env; // 変数のバインディングを保持する環境\n  updateTime; // このルールが最後に実行された時間\n\n  constructor(priority,lhs,rhs) {\n    this.priority = priority;\n    this.lhs = lhs;\n    this.rhs = rhs;\n    this.updateTime = -1;\n  }\n  toString() {\n    let str = \"\";\n    str += this.priority + \": \";\n    this.lhs.forEach((c)=>{\n      str += c.toString() + \" \";\n    });\n    str += \"> \";\n    this.rhs.forEach((a)=>{\n      str += a.toString() + \" \";\n    });\n    str += \";\";\n    return str;\n  }\n\n  // このルールの適用条件が満されているかチェック。\n  checkConditions() {\n    this.env = {};\n    let newestTime = -1;\n    for (let i=0;i<this.lhs.length;i++) {\n      const term = this.lhs[i];\n      const builtIn = this.engine.builtIns[term.name];\n      if (builtIn) {\n        try {\n          if (!builtIn.eval(term.args,this.env))\n            return false;\n          const t = term.newestTime(this.engine);\n          if (t>newestTime)\n            newestTime = t;\n        } catch(e) {\n          console.log(e);\n          return false;\n        }\n      } else {\n        console.log(`${term.name}という名前のビルトインが見付かりません。`)\n        return false;\n      }\n    }\n    //前に実行されてから状況が変っていなければ\n    //条件があっていても無意味に(?)2度以上実行されるのを防ぐ\n    if (newestTime<=this.updateTime)\n      return false;\n    return true;\n  }\n\n  // このルールの実行部を実行\n  doActions() {\n    this.updateTime = this.engine.timeCounter;\n    this.rhs.forEach((term)=>{\n      const builtIn = this.engine.builtIns[term.name];\n      if (builtIn) {\n        try {\n          builtIn.eval(term.args,this.env);\n        } catch(e) {\n          console.log(e);\n          return; // 途中終了？\n        }\n      } else {\n        console.log(`${term.name}という名前のビルトインが見付かりません。`);\n      }\n    });\n  }\n}\n\n// 処理は全てBuiltInとして実装\nclass BuiltIn {\n  name; // 名前\n  engine; // 推論エンジン\n  constructor(name,engine) {\n    this.name = name;\n    this.engine = engine;\n  }\n  eval(args,env) {\n    // 引数のargs配列と、変数と値のMapである環境envを\n    // 受け取り必要な処理を行う。\n    // このBuiltinを条件部で使うならばtrueかfalseを\n    // returnすること。処理によっては例外をthrowする\n    // ことができるものとする。\n  }\n  // 引数の数をチェックしてダメな時は例外を発生\n  checkArgsNo(args,n) {\n    if (args.length != n)\n      throw new Error(`${this.name}(${this.constructor.name}) 必ず${n}の引数を指定して下さい。`);\n  }\n  // 引数のn番目が変数かどうかチェックしてダメな時は例外を発生\n  checkArgNVar(args,n) {\n    if (args[n].constructor.name != \"Var\")\n      throw new Error(`${this.name}(${this.constructor.name}) ${n+1}番目の引数は変数でなければなりません。`);\n  }\n  // 引数のn番目が数字かどうかチェックしてダメな時は例外を発生\n  // 変数の時はその中もチェックして判断\n  checkArgNNum(args,n,env) {\n    if (typeof args[n] === \"number\")\n      return;\n    else if (args[n].constructor.name == \"Var\") {\n      const v = env[args[n].name];\n      if (typeof v === \"number\")\n        return;\n      else (typeof v === undefined || typeof v === null)\n        throw new Error(`${this.name}(${this.constructor.name}) ${n+1}番目の引数の変数は空でした。`);\n    }\n    throw new Error(`${this.name}(${this.constructor.name}) ${n+1}番目の引数は数値でなければなりません。`);\n  }\n  // 引数のn番目が文字かどうかチェックしてダメな時は例外を発生\n  // 変数の時はその中もチェックして判断\n  checkArgNStr(args,n,env) {\n    if (typeof args[n] === \"string\")\n      return;\n    else if (args[n].constructor.name == \"Var\") {\n      const v = env[args[n].name];\n      if (typeof v === \"string\")\n        return;\n      else (typeof v === undefined || typeof v === null)\n        throw new Error(`${this.name}(${this.constructor.name}) ${n+1}番目の引数の変数は空でした。`);\n    }\n    throw new Error(`${this.name}(${this.constructor.name}) ${n+1}番目の引数は文字列でなければなりません。`);\n  }\n  // 引数のn番目が値を持っているかどうかチェックしてダメな時は例外を発生\n  // 変数の時はその中もチェックして判断\n  checkArgNNoEmpty(args,n,env) {\n    if (typeof args[n] === \"number\")\n      return;\n    else if (typeof args[n] === \"string\") {\n      return;\n    } else if (args[n].constructor.name == \"Var\") {\n      const v = env[args[n].name];\n      if (typeof v === \"number\")\n        return;\n      else if (typeof v === \"string\")\n        return;\n      else (typeof v === undefined || typeof v === null)\n        throw new Error(`${this.name}(${this.constructor.name}) ${n+1}番目の引数の変数は空でした。`);\n    }\n    throw new Error(`${this.name}(${this.constructor.name}) ${n+1}番目の引数は文字列でなければなりません。`);\n  }\n  // n番目の引数から値を取り出すメソッド。変数の時はそれも展開する。\n  getValue(args,n,env) {\n    if (typeof args[n] === \"number\")\n      return args[n];\n    else if (typeof args[n] === \"string\")\n      return args[n];\n    else if (args[n].constructor.name === \"Var\") {\n      const v = env[args[n].name];\n      return v;\n    }\n  }\n  // ワーキングメモリに情報を追加または上書きする\n  setInfoToWM(infoName,value) {\n    this.engine.setInfoToWM(infoName,value);\n  }\n  // ワーキングメモリから情報を取り出す\n  getInfoFromWM(infoName) {\n    return this.engine.getInfoFromWM(infoName);\n  }\n}\n\n// 推論エンジン本体。中にルールなど全部入っている。\nclass Engine {\n  rules; // ルールの配列\n  builtIns; // ビルトインのMap\n  workingMemory; // ワーキングメモリのMap\n  stopRequest; // 推論の終了リクエスト(boolean)\n  timeCounter; // 推論ステップで進むタイムカウンタ(整数)\n  timeoutID; // setTimeoutを止めるために記録(-1の時は推論中)(整数)\n\n  constructor(ruleStr) {\n    if (ruleStr === undefined)\n      this.rules = [];\n    else\n      this.rules = (0,_parser__WEBPACK_IMPORTED_MODULE_0__.parse)(ruleStr);\n    this.rules.forEach((rule)=>{\n      rule.engine = this;\n    });\n    this.builtIns = {};\n    this.workingMemory = {};\n    this.stopRequest = true; // setInfoToWM()で勝手に動き出さないように。\n    this.timeCounter = 0;\n    this.timeoutID = 0; // 0はsetTimeout中でもなく推論中でもない時\n\n    this.addBuiltIn(new SearchBI(this));\n    this.addBuiltIn(new NoBI(this));\n    this.addBuiltIn(new GtBI(this));\n    this.addBuiltIn(new LtBI(this));\n    this.addBuiltIn(new GeBI(this));\n    this.addBuiltIn(new LeBI(this));\n    this.addBuiltIn(new EqBI(this));\n    this.addBuiltIn(new NeqBI(this));\n    this.addBuiltIn(new RangeBI(this));\n    this.addBuiltIn(new Range2BI(this));\n    this.addBuiltIn(new SeqBI(this));\n    this.addBuiltIn(new SgtBI(this));\n    this.addBuiltIn(new SltBI(this));\n    this.addBuiltIn(new SgeBI(this));\n    this.addBuiltIn(new SleBI(this));\n    this.addBuiltIn(new SetBI(this));\n    this.addBuiltIn(new StoreBI(this));\n    this.addBuiltIn(new Store2BI(this));\n    this.addBuiltIn(new DelBI(this));\n    this.addBuiltIn(new AddBI(this));\n    this.addBuiltIn(new SubBI(this));\n    this.addBuiltIn(new MulBI(this));\n    this.addBuiltIn(new DivBI(this));\n    this.addBuiltIn(new ConcatBI(this));\n    this.addBuiltIn(new LogBI(this));\n    this.addBuiltIn(new RandBI(this));\n    this.addBuiltIn(new ModBI(this));\n    this.addBuiltIn(new FloorBI(this));\n    this.addBuiltIn(new SneqBI(this));\n    this.addBuiltIn(new StopBI(this));\n  }\n\n  // ビルトインを追加\n  addBuiltIn(builtIn) {\n    this.builtIns[builtIn.name] = builtIn;\n  }\n\n  // ワーキングメモリに情報を追加または上書き\n  setInfoToWM(infoName,value) {\n    if (value === undefined) value = null;\n    this.workingMemory[infoName] = {updateTime:this.timeCounter,value};\n    if (this.stopRequest === false && this.timeoutID === 0)\n      this.start();\n  }\n\n  // ワーキングメモリから情報を取り出す\n  getInfoFromWM(infoName) {\n    const info = this.workingMemory[infoName];\n    if (!info) return undefined;\n    return info.value;\n  }\n\n  // ワーキングメモリから情報の更新時間を取り出す\n  getInfoUpdateTime(infoName) {\n    const info = this.workingMemory[infoName];\n    if (!info) return undefined;\n    return info.updateTime;\n  }\n\n  // ワーキングメモリの内容を文字列でダンプ\n  dumpWM() {\n    let str = \"\";\n    Object.keys(this.workingMemory).forEach((key)=>{\n      str += key + \":\";\n      str += this.workingMemory[key].value + \" \";\n    });\n    return str;\n  }\n\n  // 推論をスタート\n  start() {\n    this.stopRequest = false;\n    this.timeoutID = setTimeout(()=>{this.inferLoop();},0);\n  }\n\n  // 推論のループ。[照合、競合解消、実行]1セット分\n  inferLoop() {\n    this.timeoutID = -1;\n    this.timeCounter++;\n    const conflictSet = [];\n    this.rules.forEach((rule)=>{\n      if (rule.checkConditions(this.workingMemory))\n        conflictSet.push(rule);\n    });\n    let maxPriority = -1;\n    let targetRule = null;\n    conflictSet.forEach((rule)=>{\n      if (maxPriority<rule.priority) {\n        targetRule = rule;\n        maxPriority = rule.priority;\n      }\n    });\n    if (targetRule !== null) {\n      targetRule.doActions();\n    } else {\n      this.timeoutID = 0;\n      return;\n    }\n    if (this.stopRequest === false) {\n      this.timeoutID = setTimeout(()=>{this.inferLoop();},0);\n    } else {\n      this.timeoutID = 0;\n    }\n  }\n\n  // 推論を停止させます\n  stop() {\n    this.stopRequest = true;\n    clearTimeout(this.timeoutID);\n    this.timeoutID = 0;\n  }\n}\n\n/************************\n * 以下ビルトインの実装 *\n ************************/\n\n// ワーキングメモリを探索するして情報があれば変数にセットするビルトイン\nclass SearchBI extends BuiltIn {\n  constructor(engine) {super(\"s\",engine);}\n  eval(args,env) {\n    this.checkArgsNo(args,1);\n    this.checkArgNVar(args,0);\n    const v = this.getInfoFromWM(args[0].name);\n    if (v === undefined)\n      return false;\n    env[args[0].name] = v;\n    return true;\n  }\n}\n\n// 第一引数で指定した情報がワーキングメモリに\n// 無い場合にtrue．そうでない場合にfalseを返す．\nclass NoBI extends BuiltIn {\n  constructor(engine) {super(\"no\",engine);}\n  eval(args,env) {\n    this.checkArgsNo(args,1);\n    this.checkArgNVar(args,0);\n    const v = this.getInfoFromWM(args[0].name);\n    if (v === undefined)\n      return true;\n    else\n      return false;\n  }\n}\n\n// より大きい(>)の条件判断関数\nclass GtBI extends BuiltIn {\n  constructor(engine) {super(\"gt\",engine);}\n  eval(args,env) {\n  }\n}\n\n// より小さい(<)の条件判断関数\nclass LtBI extends BuiltIn {\n  constructor(engine) {super(\"lt\",engine);}\n  eval(args,env) {\n  }\n}\n\n// 以上(>=)の条件判断関数\nclass GeBI extends BuiltIn {\n  constructor(engine) {super(\"ge\",engine);}\n  eval(args,env) {\n  }\n}\n\n// 以下(<=)の条件判断関数\nclass LeBI extends BuiltIn {\n  constructor(engine) {super(\"le\",engine);}\n  eval(args,env) {\n  }\n}\n\n// 等しいかどうかの条件判断関数\nclass EqBI extends BuiltIn {\n  constructor(engine) {super(\"eq\",engine);}\n  eval(args,env) {\n  }\n}\n\n// 等しくないかどうかの条件判断関数\nclass NeqBI extends BuiltIn {\n  constructor(engine) {super(\"neq\",engine);}\n  eval(args,env) {\n  }\n}\n\n// 数値が，ある範囲におさまっているかどうかの件判断関数(>,<)\nclass RangeBI extends BuiltIn {\n  constructor(engine) {super(\"range\",engine);}\n  eval(args,env) {\n  }\n}\n\n// 数値が，ある範囲におさまっているかどうかの件判断関数(=>,<=)\nclass Range2BI extends BuiltIn {\n  constructor(engine) {super(\"range2\",engine);}\n  eval(args,env) {\n  }\n}\n\n// SeqBI = SearchBI + EqBI\nclass SeqBI extends BuiltIn {\n  constructor(engine) {super(\"seq\",engine);}\n  eval(args,env) {\n  }\n}\n\n// SgtBI = SearchBI + GtBI\nclass SgtBI extends BuiltIn {\n  constructor(engine) {super(\"sgt\",engine);}\n  eval(args,env) {\n  }\n}\n\n// SltBI = SearchBI + LtBI\nclass SltBI extends BuiltIn {\n  constructor(engine) {super(\"slt\",engine);}\n  eval(args,env) {\n  }\n}\n\n// SgeBI = SearchBI + GeBI\nclass SgeBI extends BuiltIn {\n  constructor(engine) {super(\"sge\",engine);}\n  eval(args,env) {\n  }\n}\n\n// SleBI = SearchBI + LeBI\nclass SleBI extends BuiltIn {\n  constructor(engine) {super(\"sle\",engine);}\n  eval(args,env) {\n  }\n}\n\n// 変数に値を代入するための関数\nclass SetBI extends BuiltIn {\n  constructor(engine) {super(\"set\",engine);}\n  eval(args,env) {\n  }\n}\n\n// ワーキングメモリに情報をセットする関数\n// 1つの変数を引数に取り、その変数の名前と値でセット\nclass StoreBI extends BuiltIn {\n  constructor(engine) {super(\"st\",engine);}\n  eval(args,env) {\n    this.checkArgsNo(args,1);\n    this.checkArgNVar(args,0);\n    const v = env[args[0].name];\n    this.setInfoToWM(args[0].name,v);\n    return true;\n  }\n}\n\n// ワーキングメモリに情報をセットする関数\n// 2つの引数に取り、1つ目の名前で2つ目の値をセット\nclass Store2BI extends BuiltIn {\n  constructor(engine) {super(\"st2\",engine);}\n  eval(args,env) {\n    this.checkArgsNo(args,2);\n    this.checkArgNVar(args,0);\n    const infoName = args[0].name;\n    const value = this.getValue(args,1,env);\n    this.setInfoToWM(args[0].name,value);\n  }\n}\n\n// ワーキングメモリから情報を消す関数\nclass DelBI extends BuiltIn {\n  constructor(engine) {super(\"del\",engine);}\n  eval(args,env) {\n  }\n}\n\n// 足し算を行う関数\nclass AddBI extends BuiltIn {\n  constructor(engine) {super(\"add\",engine);}\n  eval(args,env) {\n  }\n}\n\n// 引き算を行う関数\nclass SubBI extends BuiltIn {\n  constructor(engine) {super(\"sub\",engine);}\n  eval(args,env) {\n  }\n}\n\n// かけ算を行う関数\nclass MulBI extends BuiltIn {\n  constructor(engine) {super(\"mul\",engine);}\n  eval(args,env) {\n  }\n}\n\n// 割り算を行う関数\nclass DivBI extends BuiltIn {\n  constructor(engine) {super(\"div\",engine);}\n  eval(args,env) {\n  }\n}\n\n// 文字列の結合を行う関数\nclass ConcatBI extends BuiltIn {\n  constructor(engine) {super(\"concat\",engine);}\n  eval(args,env) {\n  }\n}\n\n// 文字列を標準出力に表示する関数\nclass LogBI extends BuiltIn {\n  constructor(engine) {super(\"log\",engine);}\n  eval(args,env) {\n    let str = '';\n    for (let i=0;i<args.length;i++) {\n      const v = this.getValue(args,i,env);\n      str += v;\n    }\n    console.log(str);\n  }\n}\n\n// [0.0-1.0]の乱数を生成する関数\nclass RandBI extends BuiltIn {\n  constructor(engine) {super(\"rand\",engine);}\n  eval(args,env) {\n  }\n}\n\n// あまりの計算(mod)\nclass ModBI extends BuiltIn {\n  constructor(engine) {super(\"mod\",engine);}\n  eval(args,env) {\n  }\n}\n\n// 床関数(またはガウス記号．つまり小数切り捨て)\nclass FloorBI extends BuiltIn {\n  constructor(engine) {super(\"floor\",engine);}\n  eval(args,env) {\n  }\n}\n\n// SneqFunc = SearchFunc + NeqFunc\n// sneqはseqのまったく反対ではなくあくまでSearchFunc + NeqFuncなので\n// 1つ目の引数がWMになければfalseになる点注意\n// まだDoubleとStringの場合にしか対応していない\nclass SneqBI extends BuiltIn {\n  constructor(engine) {super(\"sneq\",engine);}\n  eval(args,env) {\n  }\n}\n\n// プロダクションシステムのループ処理を強制終了させる\nclass StopBI extends BuiltIn {\n  constructor(engine) {super(\"stop\",engine);}\n  eval(args,env) {\n    this.engine.stop();\n  }\n}\n\n\n// このモジュールからExportするのは以下。ただ\n// simple-psパッケージからExportするのはEngine\n// とBuiltInだけで良いかも。\n\n\n\n//# sourceURL=webpack://SimplePS/./src/simple-ps.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});